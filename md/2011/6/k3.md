2011/jun/SI, IR Kolokvijum 3 - Jun 2011.doc
--------------------------------------------------------------------------------


1/  4 
 
Elektrotehnički fakultet u Beogradu 
Katedra za računarsku tehniku i informatiku 
 
Predmet: Operativni sistemi 1 (SI2OS1, IR 2OS1) 
Nastavnik: prof . dr Dragan Milićev 
Odsek: Softversko inženjerstvo, Računarska tehnika i informatika 
Kolokvijum: Treći, jun 2011. 
Datum: 17.6.2011. 
Kolokvijum iz Operativnih sistema 1 
Kandidat:
 _____________________________________________________________ 
Broj indeksa: ________________  E-mail:______________________________________ 
 
Kolokvijum traje 1,5 sat. Dozvoljeno je korišćenje literature. 
Zadatak 1 _______________/10   Zadatak 3 _______________/10 
Zadatak 2 _______________/10    
 
Ukupno: __________/30 = __________% = _________/10 
Napomena: Ukoliko u zadatku nešto nije dovoljno precizno definisano, student treba da 
uvede razumnu pretpostavku, da je uokviri (da bi se lakše prepoznala prilikom ocenjivanja) i 
da  nastavi  da  izgrađuje  preostali  deo  svog  odgovora  na  temeljima  uvedene  pretpostavke. 
Ocenjivanje unutar potpitanja je po sistemu "sve ili ništa", odnosno nema parcijalnih poena. 
Kod pitanja koja imaju ponuđene odgovore treba samo zaokružiti jedan odgovor. Na ostala 
pitanja odgovarati čitko, kratko i precizno. 
 

2/  4 
1. (10 poena) 
Real izovati u potpunosti klasu 
DoubleBuffer čiji je interfejs dat. Ova klasa implementira 
dvostruki bafer . Proizvođač stavlja element tipa Data* pozivom operacije put(), čime se 
element stavlja u trenutni „izlazni“ bafer od dva interna bafera, dok potrošač uzima elemente 
iz  trenutnog  „ulaznog“  bafera  pozivom  operacije get().  Kada  obojica  završe  sa  svojim 
baferom,  baferi  zamenjuju  uloge.  Proizvođač  i  potrošač  su  uporedne  niti  (ne  treba  ih 
realizovati), dok je sva potrebna sinhronizacija unutar klase 
DoubleBuffer. Za sinhronizaciju 
koristiti semafore. 
class Data; 
 
class DoubleBuffer { 
public: 
  DoubleBuffer (int size); 
  void  put (Data*); 
  Data* get (); 
private: 
  ... 
}; 
Rešenje:

3/  4 
2. (10 poena) 
U nekom operativnom sistemu struktura PCB sadrži polje 
open_files koje je pokazivač na 
tabelu otovorenih fajlova tog procesa. U toj tabeli (zapravo nizu), svaki ulaz je struktura koja 
predstavlja deskriptor jednog otvorenog fajla. U toj strukturi postoji celobrojno polje access 
čija vrednost 1 označava da je dati proces otvorio dati fajl sa pravom na upis, a vrednost 0 
ozna čava da je dati proces otvorio dati fajl samo sa pravom na čitanje. Promenljiva tipa 
FHANDLE predstavlja indeks u tabeli otvorenih fajlova datog procesa u čijem je kontekstu 
otvaren fajl. Implementirati operaciju 
check_access() čiji je potpis dat, a koju poziva fajl 
podsistem u svakom sistemskom pozivu za pristup sadržaju fajla radi provere prava datog 
procesa na izvršavanje date operacije nad sadržajem fajla. Argument p je pokazivač na PCB 
procesa koji je izdao sistemski poziv, argument 
f je identifikator fajla, a argument write ima 
vrednost 0 ako sistemski poziv zahteva samo čitanje, odnosno vrednost 1 ako sistemski poziv 
zahteva upis u dati fajl. 
int check_access (PCB* p, FHANDLE f, int write); 
Rešenje: 

4/  4 
3. (10 poena) 
Neki  fajl  sistem  koristi  FAT, uz  dodatni  mehanizam  detekcije  i  oporavka  od  korupcije 
ulančanih lista na sledeći način. Kada se FAT kešira u memoriji, vidi se kao niz struktura tipa 
FATEntry. Ova struktura ima dva celobrojna polja. Polje next je broj ulaza u FAT u kome se 
nalazi sledeći element u ulančanoj listi; vrednost 0 označava kraj liste . Polje 
fid ove strukture 
sadrži identifikator fajla kome pripada taj  element liste. U strukturi FCB  celobrojno polje id 
predstavlja identifikator datog fajla, a polje head sadrži redni broj ulaza u FAT koji je prvi 
element u ulančanoj listi datog fajla. 
Implementirati funkciju čiji je potpis dat dole. Ona treba da proveri konzistentnost ulančane 
liste datog fajla, proverom da li svi elementi liste pripadaju baš   tom fajlu. Ukoliko je sve u 
redu, ova funkcija treba da vrati 1. Ukoliko naiđe na element u listi koji je pogrešno ulančan, 
odnosno ne pripada tom fajlu (tako što polje 
fid ne odgovara identifikatoru tog fajla), taj 
pogrešno ulančani ostatak liste treba da „odseče“ postavljanjem terminatora liste (vrednost 0 u 
polje 
next) u poslednji ispravan element liste (ili glavu liste, ako je prvi element pogrešan) i 
da vrati 0. 
FATEntry FAT[...]; 
 
int check_consistency (FCB* file); 
Rešenje: 